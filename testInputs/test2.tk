; r0 - 0 (input port)
; r1 - list size
; r2 - address of low
; r3 - populate list label
; r4 - input list element
; r6 - address of high
; r7 - goal element
; r8 - address of mid
; r9 - stores 2
; r10 - element at mid
; r11 - stores the difference of mid element and goal element
; r12 - address of notfound
; r13 - address of LeftHalf
; r14 - address of search
; r15 - address of FindHalf
; r16 - stores 8
; r17 - stores 3
; r29 - stores "not "
; r30 - stores "found\n"
.code
; Storing number to divide by
	addi r9, 2
	addi r16, 8
	addi r17, 3
; Read in list size
	in r1, r0
; Storing the low element address
	mov r2, r31
	subi r2, 8
; Load in label addresses
	ld r3, :PopulateList
	ld r12, :NotFound
	ld r13, :LeftHalf
	ld r14, :Search
	ld r15, :FindHalf
:PopulateList
	in r4, r0
	push r4
; Decrementing loop counter
	subi r1, 1
; Going back to check if list size is 0
	brnz r3, r1
; Storing address of high in r2
	mov r6, r31
; Reading in goal element
	in r7, r0
:Search
; Calculating halfway address
	sub r8, r2, r6
	div r8, r8, r9
	sub r8, r2, r8
	div r8, r8, r16
	mul r8, r8, r16
; Accessing element at halfway address
	mov r10, (r8)(0)
	sub r11, r10, r7
; branch if not found
	brnz r12, r11
	ld r30, 102
	out r17, r30
	ld r30, 111
	out r17, r30
	ld r30, 117
	out r17, r30
	ld r30, 110
	out r17, r30
	ld r30, 100
	out r17, r30
	halt
:NotFound
; Checking if not in list
	brgt r15, r2, r6
	ld r30, 110
	out r17, r30
	ld r30, 111
	out r17, r30
	ld r30, 116
	out r17, r30
	ld r30, 32
	out r17, r30
	ld r30, 102
	out r17, r30
	ld r30, 111
	out r17, r30
	ld r30, 117
	out r17, r30
	ld r30, 110
	out r17, r30
	ld r30, 100
	out r17, r30
	halt
:FindHalf
; Checking if in right half
	brgt r13, r10, r7
	mov r2, r8
	subi r2, 8
	br r14
:LeftHalf
	mov r6, r8
	addi r6, 8
	br r14